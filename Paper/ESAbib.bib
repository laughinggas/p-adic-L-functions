@book {cyc,
    AUTHOR = {Washington, Lawrence C.},
     TITLE = {Introduction to cyclotomic fields},
    SERIES = {Graduate Texts in Mathematics},
    VOLUME = {83},
   EDITION = {Second},
 PUBLISHER = {Springer-Verlag, New York},
      YEAR = {1997},
     PAGES = {xiv+487},
      ISBN = {0-387-94762-0},
   MRCLASS = {11R18 (11-01 11-02 11R23)},
  MRNUMBER = {1421575},
MRREVIEWER = {T. Mets\"{a}nkyl\"{a}},
       DOI = {10.1007/978-1-4612-1934-7},
       URL = {https://doi.org/10.1007/978-1-4612-1934-7},
}

@article {KL,
    AUTHOR = {Kubota, Tomio and Leopoldt, Heinrich-Wolfgang},
     TITLE = {Eine {$p$}-adische {T}heorie der {Z}etawerte. {I}.
              {E}inf\"{u}hrung der {$p$}-adischen {D}irichletschen
              {$L$}-{F}unktionen},
   JOURNAL = {J. Reine Angew. Math.},
  FJOURNAL = {Journal f\"{u}r die Reine und Angewandte Mathematik. [Crelle's
              Journal]},
    VOLUME = {214(215)},
      YEAR = {1964},
     PAGES = {328--339},
      ISSN = {0075-4102},
   MRCLASS = {10.67 (10.41)},
  MRNUMBER = {163900},
MRREVIEWER = {D. J. Lewis},
}

@misc{TPIL, title={Theorem Proving in Lean}, url={https://kilthub.cmu.edu/articles/journal_contribution/Theorem_Proving_in_Lean/6492902/1}, DOI={10.1184/R1/6492902.v1}, abstractNote={
Formal verification involves the use of logical and computational methods to establish claims that are expressed in precise mathematical terms. These can include ordinary mathematical theorems, as well as claims that pieces of hardware or software, network protocols, and mechanical and hybrid systems meet their specifications. In practice, there is not a sharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal verification requires describing hardware and software systems in mathematical terms, at which point establishing claims as to their correctness becomes a form of theorem proving. Conversely, the proof of a mathematical theorem may require a lengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what it is supposed to do.

The gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic show most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of foundational systems. With this reduction, there are two ways that a computer can help establish a claim: it can help find a proof in the first place, and it can help verify that a purported proof is correct.

Automated theorem proving focuses on the “finding” aspect. Resolution theorem provers, tableau theorem provers, fast satisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and first-order logic. Other systems provide search procedures and decision procedures for specific languages and domains, such as linear or nonlinear expressions over the integers or the real numbers. Architectures like SMT (“satisfiability modulo theories”) combine domain-general search methods with domain-specific procedures. Computer algebra systems and specialized mathematical software packages provide means of carrying out mathematical computations, establishing mathematical bounds, or finding mathematical objects. A calculation can be viewed as a proof as well, and these systems, too, help establish mathematical claims.

Automated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness. Such systems can have bugs, and it can be difficult to ensure that the results they deliver are correct. In contrast, interactive theorem proving focuses on the “verification” aspect of theorem proving, requiring that every claim is supported by a proof in a suitable axiomatic foundation. This sets a very high standard: every rule of inference and every step of a calculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and rules. In fact, most such systems provide fully elaborated “proof objects” that can be communicated to other systems and checked independently. Constructing such proofs typically requires much more input and interaction from users, but it allows us to obtain deeper and more complex proofs.

The Lean Theorem Prover aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify claims in both domains.

}, publisher={Carnegie Mellon University}, author={Avigad, Jeremy and de Moura, Leonardo and Kong, Soonho}, year={2018}, month={Jun} } 

@inproceedings{mathlib,
author = {{The mathlib Community}},
editor={Blanchette, J. and Hrițcu, C.},
title = {The {L}ean Mathematical Library},
year = {2020},
isbn = {9781450370974},
publisher = {ACM},
doi = {10.1145/3372885.3373824},
booktitle = {CPP 2020},
pages = {367–381},
numpages = {15},
keywords = {formal library, mathlib, formal proof, Lean},
}

@article{DD,
author={Baanen, Anne
and Dahmen, Sander R.
and Narayanan, Ashvni
and Nuccio Mortarino Majno di Capriglio, Filippo A. E.},
title={A Formalization of Dedekind Domains and Class Groups of Global Fields},
journal={Journal of Automated Reasoning},
year={2022},
month={Nov},
day={01},
volume={66},
number={4},
pages={611-637},
abstract={Dedekind domains and their class groups are notions in commutative algebra that are essential in algebraic number theory. We formalized these structures and several fundamental properties, including number-theoretic finiteness results for class groups, in the Lean prover as part of the mathlib mathematical library. This paper describes the formalization process, noting the idioms we found useful in our development and mathlib's decentralized collaboration processes involved in this project.},
issn={1573-0670},
doi={10.1007/s10817-022-09644-0},
url={https://doi.org/10.1007/s10817-022-09644-0}
}

@misc{ML,
  doi = {10.48550/ARXIV.2211.07524},
  
  url = {https://arxiv.org/abs/2211.07524},
  
  author = {Agrawal, Ayush and Gadgil, Siddhartha and Goyal, Navin and Narayanan, Ashvni and Tadipatri, Anand},
  
  keywords = {Computation and Language (cs.CL), Artificial Intelligence (cs.AI), FOS: Computer and information sciences, FOS: Computer and information sciences},
  
  title = {Towards a Mathematics Formalisation Assistant using Large Language Models},
  
  publisher = {arXiv},
  
  year = {2022},
  
  copyright = {Creative Commons Attribution Share Alike 4.0 International}
}

@article{KT,
author = {Jun Ueki},
title = {{On the Iwasawa $\mu$-invariants of branched $\mathbf{Z}_{p}$-covers}},
volume = {92},
journal = {Proceedings of the Japan Academy, Series A, Mathematical Sciences},
number = {6},
publisher = {The Japan Academy},
pages = {67 -- 72},
abstract = {Following the analogies between knots and primes, we establish relative genus theory for a branched cover of rational homology 3-spheres. Then we formulate analogues of Iwasawa’s theorems on $\mu$-invariants for branched $\mathbf{Z}_{p}$-covers of rational homology 3-spheres, by using relative genus theory.},
keywords = {Arithmetic topology, branched covering, Iwasawa theory, link, rational homology 3-sphere, relative genus theory},
year = {2016},
doi = {10.3792/pjaa.92.67},
URL = {https://doi.org/10.3792/pjaa.92.67}
}

@misc{DBLP,
  doi = {10.48550/ARXIV.2104.00270},
  
  url = {https://arxiv.org/abs/2104.00270},
  
  author = {Sandhan, Jivnesh and Adideva, Om and Komal, Digumarthi and Behera, Laxmidhar and Goyal, Pawan},
  
  keywords = {Computation and Language (cs.CL), FOS: Computer and information sciences, FOS: Computer and information sciences},
  
  title = {Evaluating Neural Word Embeddings for Sanskrit},
  
  publisher = {arXiv},
  
  year = {2021},
  
  copyright = {Creative Commons Attribution 4.0 International}
}

@misc{Sanskrit2,
  doi = {10.48550/ARXIV.2004.08076},
  
  url = {https://arxiv.org/abs/2004.08076},
  
  author = {Krishna, Amrith and Gupta, Ashim and Garasangi, Deepak and Sandhan, Jivnesh and Satuluri, Pavankumar and Goyal, Pawan},
  
  keywords = {Computation and Language (cs.CL), FOS: Computer and information sciences, FOS: Computer and information sciences},
  
  title = {Neural Approaches for Data Driven Dependency Parsing in Sanskrit},
  
  publisher = {arXiv},
  
  year = {2020},
  
  copyright = {arXiv.org perpetual, non-exclusive license}
}

@article{Briggs_1985, title={Knowledge Representation in Sanskrit and Artificial Intelligence}, volume={6}, url={https://ojs.aaai.org/index.php/aimagazine/article/view/466}, DOI={10.1609/aimag.v6i1.466}, abstractNote={In the past twenty years, much time, effort, and money has been expended on designing an unambiguous representation of natural language to make them accessible to computer processing, These efforts have centered around creating schemata designed to parallel logical relations with relations expressed by the syntax and semantics of natural languages, which are clearly cumbersome and ambiguous in their function as vehicles for the transmission of logical data. Understandably, there is a widespread belief that natural languages are unsuitable for the transmission of many ideas that artificial languages can render with great precision and mathematical rigor. But this dichotomy, which has served as a premise underlying much work in the areas of linguistics and artificial intelligence, is a false one. There is at least one language, Sanskrit, which for the duration of almost 1000 years was a living spoken language with a considerable literature of its own. Besides works of literary value, there was a long philosophical and grammatical tradition that has continued to exist with undiminished vigor until the present century. Among the accomplishments of the grammarians can be reckoned a method for paraphrasing Sanskrit in a manner that is identical not only in essence but in form with current work in Artificial Intelligence. This article demonstrates that a natural language can serve as an artificial language also, and that much work in AI has been reinventing a wheel millenia old. First, a typical Knowledge Representation Scheme (using Semantic Nets) will be laid out, followed by an outline of the method used by the ancient Indian grammarians to analyze sentences unambiguously. Finally, the clear parallelism between the two will be demonstrated, and the theoretical implications of this equivalence will be given.}, number={1}, journal={AI Magazine}, author={Briggs, Rick}, year={1985}, month={Mar.}, pages={32} }

